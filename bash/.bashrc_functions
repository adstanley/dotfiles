#!/usr/bin/env bash
# shellcheck source=.bashrc

#################################################################################
#                                    Functions                                  #
#################################################################################

declare -A FUNCTION_HELP

#@Name: ownroot
#@Description: Change ownership to root
#@Usage: ownroot [directory] [--force]
#@define help information
FUNCTION_HELP[ownroot]=$(cat << 'EOF'
NAME
    ownroot - Change ownership to root
USAGE
    ownroot [DIRECTORY] [--force]
EXAMPLES
    ownroot /path/to/directory
    ownroot .
    ownroot /path/to/directory --force
DESCRIPTION
    Changes ownership of the specified directory and its contents to root:root
    and sets permissions to 755 for directories and 644 for files.
    Use --force to bypass confirmation prompt (non-interactive mode).
EOF
)

#@begin_function ownroot
function ownroot() {
    local force=0
    local target_dir="${1:-.}"

    # Handle arguments
    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        if [[ -n "${FUNCTION_HELP[${FUNCNAME[0]}]}" ]]; then
            echo "${FUNCTION_HELP[${FUNCNAME[0]}]}"
        else
            echo "Help not available for function: ${FUNCNAME[0]}" >&2
            return 2
        fi
        return 0
    fi

    if [[ "$2" == "--force" ]]; then
        force=1
    elif [[ $# -gt 1 ]]; then
        echo "Error: Invalid arguments. Usage: ownroot [DIRECTORY] [--force]" >&2
        return 1
    fi

    # Check for root privileges
    if [[ $EUID -ne 0 ]]; then
        echo "Error: This script must be run as root." >&2
        return 1
    fi

    # Resolve target directory
    if ! command -v readlink >/dev/null 2>&1; then
        echo "Error: readlink is required but not installed." >&2
        return 1
    fi
    target_dir=$(readlink -f "$target_dir")

    # Check if the target directory exists
    if [[ ! -d "$target_dir" ]]; then
        printf "Error: %s is not a directory.\n" "$target_dir" >&2
        return 1
    fi

    # Define critical directories
    local -a critical_dirs=(
        "/"
        "/boot"
        "/home"
        "/root"
        "/etc"
        "/var"
        "/usr"
        "/bin"
        "/sbin"
        "/lib"
        "/lib64"
        "/dev"
        "/proc"
        "/sys"
        "/tmp"
        "/opt"
        "/srv"
        "/media"
        "/mnt"
    )

    # Check if target_dir is a critical directory or a subdirectory
    for dir in "${critical_dirs[@]}"; do
        if [[ "$target_dir" == "$dir" || "$target_dir" == "$dir"/* ]]; then
            echo "Error: '$target_dir' is a critical system directory or subdirectory." >&2
            return 1
        fi
    done

    # Sanity Check
    if [[ $force -eq 0 && -t 0 ]]; then  # Prompt only if not forced and stdin is a terminal
        echo "WARNING: Changing ownership of '$target_dir' to root:root may make files inaccessible to non-root users."
        read -t 30 -rp "Are you sure you want to proceed? [y/N] " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo "Operation cancelled." >&2
            return 1
        fi
    elif [[ $force -eq 0 ]]; then
        echo "Error: This script requires interactive confirmation. Use --force to bypass." >&2
        return 1
    fi

    # Change ownership and permissions recursively
    chown -R -v root:root "$target_dir"
    find "$target_dir" -type d -exec chmod -v 755 {} \;
    # find "$target_dir" -type f -exec chmod -v 644 {} \;
}
#@end_function